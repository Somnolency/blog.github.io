{"meta":{"title":"追光随笔","subtitle":"","description":"个人博客, 追光, Somnolency","author":"追光","url":"https://ior.ink","root":"/"},"pages":[{"title":"","date":"2023-11-25T19:25:19.126Z","updated":"2023-11-25T19:25:19.126Z","comments":true,"path":"404.html","permalink":"https://ior.ink/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-11-25T19:25:19.126Z","updated":"2023-11-25T19:25:19.126Z","comments":false,"path":"about/index.html","permalink":"https://ior.ink/about/index.html","excerpt":"","text":"# 我是谁 一个有点多愁善感的电子类专业大学生，目前正在体验大学除了比赛的一切，已经在大学稀里糊涂的过了两年，对了，目前有一个可爱漂亮的女朋友。(&#x3D;^▽^&#x3D;) # 这是哪里 这是我的博客，应该是我的第三个博客，前两个博客分别是是在初中和高中时写的，后来因为学习停止了写博客。这是一个通过Hexo框架和Volantis主题建立的卡片式博客，平常用来写自己的反思及自己的学习笔记。我在这个主题上删减了很多内容，因为我喜欢极简风格，不必要的东西就删去了，包括评论。所以，如果有问题就发邮件给我，邮箱地址为&#x73;&#111;&#109;&#x6e;&#x6f;&#108;&#x65;&#x6e;&#99;&#121;&#x40;&#x6f;&#x75;&#x74;&#x6c;&#111;&#111;&#x6b;&#46;&#x63;&#111;&#x6d; # 关于文章 博客的内容大部分应该是关于硬件设计及单片机方面的内容，也或者是是我在C&#x2F;C++,Python,Lua上的一些折腾，以及Linux系统方面的一切，毕竟我是一个爱折腾的人。我也会将此博客作为自己的一个日记本，一个公开的日记本，记录大学日常的琐碎生活，也欢迎各位志同道合的朋友来添加友链。"},{"title":"所有分类","date":"2023-11-25T19:25:19.126Z","updated":"2023-11-25T19:25:19.126Z","comments":true,"path":"categories/index.html","permalink":"https://ior.ink/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-11-25T19:25:19.126Z","updated":"2023-11-25T19:25:19.126Z","comments":true,"path":"friends/index.html","permalink":"https://ior.ink/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。"},{"title":"所有标签","date":"2023-11-25T19:25:19.126Z","updated":"2023-11-25T19:25:19.126Z","comments":false,"path":"tags/index.html","permalink":"https://ior.ink/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"KNN算法简单实现","slug":"KNN算法简单实现","date":"2023-05-10T23:53:58.000Z","updated":"2023-11-25T19:25:19.126Z","comments":false,"path":"posts/3dbe41d6.html","link":"","permalink":"https://ior.ink/posts/3dbe41d6.html","excerpt":"最近在机器学习课堂上学习了KNN算法，在课程作业中终于出现了KNN算法具体实现的题目，在此记录一下我的解题思路.","text":"最近在机器学习课堂上学习了KNN算法，在课程作业中终于出现了KNN算法具体实现的题目，在此记录一下我的解题思路. 题目说明补充 python 代码，完成 kNNClassifier 类中的 fit 函数与 predict 函数。实现 kNN 算法的训练与预测功能。 基础代码如下： #encoding=utf8 import numpy as np class kNNClassifier(object): def __init__(self, k): &#39;&#39;&#39; 初始化函数 :param k:kNN算法中的k &#39;&#39;&#39; self.k = k # 用来存放训练数据，类型为ndarray self.train_feature = None # 用来存放训练标签，类型为ndarray self.train_label = None def fit(self, feature, label): &#39;&#39;&#39; kNN算法的训练过程 :param feature: 训练集数据，类型为ndarray :param label: 训练集标签，类型为ndarray :题目是return: 无返回 &#39;&#39;&#39; #********* Begin *********# #********* End *********# def predict(self, feature): &#39;&#39;&#39; kNN算法的预测过程 :param feature: 测试集数据，类型为ndarray :return: 预测结果，类型为ndarray或list &#39;&#39;&#39; #********* Begin *********# #********* End *********# 解题思路1.题目是要求实现kNNClassifier中的fit方法，fit()方法会接受两个参数：训练数据X和目标变量y。 其中，X是一个二维数组，包含了训练样本点的特征向量，每行代表一个样本点，每列代表一个特征。如 [ [x1,y1,z1,w1] [x2,y2,z2,w2] [x3,y3,z3,w3] ... ] y是一个一维数组，包含了训练样本点的目标变量，即每个样本点的分类标签。如 [label1, label2, label3, ...] fit()方法利用给定的训练数据集生成一个KNN模型，其作用有点像在空白纸上将数据中的点根据(x,y)的值绘制出来。接下来的预测则是把不确定的点也在该纸上画出来，并且找到离不确定点的距离最近的几个点。 所以fit()的功能应该是储存数据，以便被预测函数调用。 2.kNNClassifier中的predict()方法有额外一个参数，该参数是需要预测标签的点或者是点的集合。 在predict()中，首先要计算预测点离模型中每个点的距离，然后选出距离该点最近的K个点，统计K个点的标签，出现次数最多的标签则为预测点的标签。 3.在确定了两个函数的大概方法后，为了解题方便最好再确认一下所给数据的格式，每个数据的格式如下 print(feature.shape) ===&gt; (38, 4) print(self.train_feature.shape) ===&gt; (112, 4) print(self.train_label.shape) ===&gt; (112,) 根据上面的信息可以得出，训练数据集中共有112个数据，每个数据都有4个特征和一个标签；预测数据集中有38个数据，每个数据也都是4个特征，需要根据对应4个特征预测出其标签。 每次都从预测数据集中取出一个数据放入模型中，最后返回的标签也需要以集合的形式返回，所以在predict函数中需要使用for循环。 具体实现 fit()方法的实现 def fit(self, feature, label): &#39;&#39;&#39; kNN算法的训练过程 :param feature: 训练集数据，类型为ndarray :param label: 训练集标签，类型为ndarray :return: 无返回 &#39;&#39;&#39; #********* Begin *********# self.train_feature = feature self.train_label = label #********* End *********# predict()方法的实现 def predict(self, feature): &#39;&#39;&#39; kNN算法的预测过程 :param feature: 测试集数据，类型为ndarray :return: 预测结果，类型为ndarray或list &#39;&#39;&#39; #********* Begin *********# # 确定数据的个数 num_test = feature.shape[0] # 定义返回标签集合 y_pred = np.zeros(num_test, dtype = self.train_label.dtype) # 每次取出一个预测数据 for i in range(num_test): # 计算预测值特征与模型中每个点特征值的差 error = np.abs(self.train_feature - feature[i,:]) # 将4个特征值的差合并为一个差，并将其定义为距离 distances = np.sum(error, axis = 1) # 返回distances中从大到小的前K个数的索引 indices = np.argsort(distances)[:self.k] # 将feature中的索引转换成对应的标签 # self.train_label[indices]返回最大距离数据对应的标签 feature_to_label = self.train_label[indices] # 将出现次数最多的标签置入对应的标签组中 # np.argmax(np.bincount(array)) 返回数组中出现次数最多的数 y_pred[i] = np.argmax(np.bincount(feature_to_label)) return y_pred","categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://ior.ink/tags/python/"}]},{"title":"hexo博客文章、分类、标签网址全英文化","slug":"hexo博客文章、分类、标签网址全英文化","date":"2023-04-21T14:00:36.000Z","updated":"2023-11-25T19:25:19.126Z","comments":false,"path":"posts/5120accd.html","link":"","permalink":"https://ior.ink/posts/5120accd.html","excerpt":"本文将帮助你使用abbrlink、tag_map和category_map实现URL路径全英文。","text":"本文将帮助你使用abbrlink、tag_map和category_map实现URL路径全英文。 文章链接去中文1.首先在博客根目录运行Git Bash，输入以下指令安装hexo-abbrlink： npm install hexo-abbrlink --save 2.打开站点配置文件 _config.yml，修改permalink为： permalink: posts/:abbrlink.html 3,.在站点配置文件 _config.yml 中添加以下代码： #abbrlink配置 abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 注：其中alg和rep为算法和进制 算法 进制 crc16 hex crc32 dec 4.修改文件后，重新生成文章即可 hexo clean hexo g 分类去中文化使用category_map实现分组映射 打开站点配置文件 _config.yml，修改 category_map: # Category &amp; Tag default_category: uncatalog ## 为了让中文分组名在网址中显示为英文，我们可以创建分组名映射（category_map）： category_map: &#39;Adobe脚本语言学习&#39; : adobe-extendscript &#39;Android基础&#39; : android-base &#39;Android案例实现&#39; : android-training &#39;Hexo&#39; : hexo 标签去中文化使用tag_map实现分组映射 打开站点配置文件**_config.yml，修改tag_map**: # Category &amp; Tag default_category: uncatalog ## 为了让中文分组名在网址中显示为英文，我们可以创建分组名映射（category_map）： category_map: &#39;Adobe脚本语言学习&#39; : adobe-extendscript &#39;Android基础&#39; : android-base &#39;Android案例实现&#39; : android-training &#39;Hexo&#39; : hexo tag_map: &#39;标签一&#39; : tag1 &#39;标签二&#39; : tag2","categories":[{"name":"杂项","slug":"Miscellaneous","permalink":"https://ior.ink/categories/Miscellaneous/"}],"tags":[{"name":"YAML","slug":"yaml","permalink":"https://ior.ink/tags/yaml/"}]},{"title":"volantis自定义主题","slug":"volantis自定义主题","date":"2022-11-25T00:06:55.000Z","updated":"2023-11-25T19:25:19.126Z","comments":false,"path":"posts/79aa5ff0.html","link":"","permalink":"https://ior.ink/posts/79aa5ff0.html","excerpt":"","text":"在实际使用过程中，虽然可以通过_config.volantis.yaml文件来设置主题，但是这些设置都是在volantis内置模板的基础上实现的。如果对某个模板不太满意，就需要自己动手更改模板。好在volantis提供的强大自定义功能。 # 修改布局 布局通过ejs文件来实现，ejs的语法非常简单，可以在其ejs官网找到。 修改布局有两种方法，不管哪一种方法，都需要创建 blog&#x2F;source&#x2F;_volantis&#x2F; 文件夹，并在该文件夹中添加自定义的ejs文件或者styl文件。 # 注入修改法 注入修改法是volantis官方推荐的修改方法，通过向留在特定文件的注入点添加内容实现修改。你仅能在特定文件的开头与结尾添加自己的代码，无法修改原来存在的代码。 需要注意的是，你需要在_volantis文件夹中创建特定名称的ejs文件。例如你在 _volantis&#x2F;bodyEnd.ejs 文件中写入的代码会被注入到 theme&#x2F;layout&#x2F;layout.ejs 文件的 标签末尾。具体的文件名称与注入点如下所示： headBegin.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;head.ejs 文件 标签开头注入自定义内容. headEnd.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;head.ejs 文件 标签末尾注入自定义内容. header.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;header.ejs 文件 导航栏 .nav-main 末尾注入自定义内容. side.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;side.ejs 文件 侧边栏 #l_side 末尾注入自定义内容. topMeta.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;meta.ejs 文件 topMetas 末尾注入自定义内容. bottomMeta.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;meta.ejs 文件 bottomMetas 末尾注入自定义内容. footer.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;footer.ejs 文件 标签末尾注入自定义内容. postEnd.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;article.ejs 文件 标签末尾注入自定义内容. bodyBegin.ejs: 向 theme&#x2F;layout&#x2F;layout.ejs 文件 标签开头注入自定义内容. bodyEnd.ejs: 向 theme&#x2F;layout&#x2F;layout.ejs 文件 标签末尾注入自定义内容. # 重写修改法 如果对已有的布局不满意，你也可以选择重写，建议重写的文件放置在 _volantis 文件夹下，并与源文件名称一致。为了用重写的文件替代源文件，你需要 hexo-extend-theme 插件，该插件的使用方法可以在插件的ReadMe文件中看。 # 修改样式表 样式表的修改和布局一样，都可以在文档中找到","categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"}],"tags":[{"name":"JS","slug":"js","permalink":"https://ior.ink/tags/js/"}]}],"categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"},{"name":"杂项","slug":"Miscellaneous","permalink":"https://ior.ink/categories/Miscellaneous/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://ior.ink/tags/python/"},{"name":"YAML","slug":"yaml","permalink":"https://ior.ink/tags/yaml/"},{"name":"JS","slug":"js","permalink":"https://ior.ink/tags/js/"}]}