{"meta":{"title":"追光随笔","subtitle":"","description":"个人博客, 追光, Somnolency","author":"追光","url":"https://ior.ink","root":"/"},"pages":[{"title":"","date":"2024-11-10T08:23:45.894Z","updated":"2024-11-10T08:23:45.894Z","comments":true,"path":"404.html","permalink":"https://ior.ink/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-11-10T08:23:45.894Z","updated":"2024-11-10T08:23:45.894Z","comments":false,"path":"about/index.html","permalink":"https://ior.ink/about/index.html","excerpt":"","text":"# 我是谁 一个有点多愁善感的电子类专业大学生，目前正在体验大学除了比赛的一切，已经在大学稀里糊涂的过了两年，对了，目前有一个可爱漂亮的女朋友。(&#x3D;^▽^&#x3D;) # 这是哪里 这是我的博客，应该是我的第三个博客，前两个博客分别是是在初中和高中时写的，后来因为学习停止了写博客。这是一个通过Hexo框架和Volantis主题建立的卡片式博客，平常用来写自己的反思及自己的学习笔记。我在这个主题上删减了很多内容，因为我喜欢极简风格，不必要的东西就删去了，包括评论。所以，如果有问题就发邮件给我，邮箱地址为&#115;&#x6f;&#109;&#x6e;&#111;&#108;&#x65;&#110;&#x63;&#121;&#64;&#x6f;&#117;&#x74;&#x6c;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#x6f;&#x6d; # 关于文章 博客的内容大部分应该是关于硬件设计及单片机方面的内容，也或者是是我在C&#x2F;C++,Python,Lua上的一些折腾，以及Linux系统方面的一切，毕竟我是一个爱折腾的人。我也会将此博客作为自己的一个日记本，一个公开的日记本，记录大学日常的琐碎生活，也欢迎各位志同道合的朋友来添加友链。"},{"title":"所有分类","date":"2024-11-10T08:23:45.894Z","updated":"2024-11-10T08:23:45.894Z","comments":true,"path":"categories/index.html","permalink":"https://ior.ink/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-11-10T08:23:45.898Z","updated":"2024-11-10T08:23:45.898Z","comments":true,"path":"friends/index.html","permalink":"https://ior.ink/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。"},{"title":"所有标签","date":"2024-11-10T08:23:45.898Z","updated":"2024-11-10T08:23:45.898Z","comments":false,"path":"tags/index.html","permalink":"https://ior.ink/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用快捷指令实现while循环以及基础函数","slug":"使用快捷指令实现c语言函数","date":"2024-11-10T08:23:45.894Z","updated":"2024-11-10T08:23:45.894Z","comments":false,"path":"posts/efac1849.html","link":"","permalink":"https://ior.ink/posts/efac1849.html","excerpt":"iOS的快捷指令是个好东西，但是很多地方却用起来特别别扭，本人用了一个下午的时间用快捷指令实现了c语言的一些功能。还有更多的想法目前还未实现，希望我的这些思考能够抛砖引玉。","text":"iOS的快捷指令是个好东西，但是很多地方却用起来特别别扭，本人用了一个下午的时间用快捷指令实现了c语言的一些功能。还有更多的想法目前还未实现，希望我的这些思考能够抛砖引玉。 while循环while循环可以通过递归与if语言来实现，由于我不清楚ios快捷指令的特性，所以我选择使用词典作为传递递归停止条件与变量的方式。下面使用c语言来演示一下原理 #include &lt;stdio.h&gt; // 定义一个递归函数，参数n表示当前要打印的数字 void print_loop(int n) &#123; // 如果n小于等于10，就打印n，并继续调用自身，将n加1 if (n &lt;= 10) &#123; printf(&quot;%d\\n&quot;, n); print_loop(n + 1); &#125; // 否则，就退出函数，结束递归 else &#123; return; &#125; &#125; int main() &#123; // 调用递归函数，从1开始打印 print_loop(1); return 0; &#125; 遍历#include &lt;stdio.h&gt; int main() &#123; int lst[] = &#123;1, 2, 3, 4, 5&#125;; // 定义一个数组 int len = sizeof(lst) / sizeof(lst[0]); // 计算数组的长度 int i = 0; // 定义一个索引变量，初始化为0 while (1) &#123; // 无限循环 if (i &lt; len) &#123; // 如果索引变量小于数组的长度 printf(&quot;%d\\n&quot;, lst[i]); // 打印数组中的元素 i++; // 将索引变量加1 &#125; else &#123; break; // 跳出循环 &#125; &#125; return 0; &#125; ios快捷指令与C语言的等效语法 变量：iOS快捷指令中可以使用“添加到变量”和“获取变量”操作来创建和访问变量，C语言中可以使用变量名和赋值语句来创建和访问变量。 数据类型：iOS快捷指令中可以使用“文本”、“数字”、“布尔值”、“日期”、“字典”、“列表”等数据类型，C语言中可以使用“char”、“int”、“float”、“double”、“bool”、“struct”、“array”等数据类型。 控制结构：iOS快捷指令中可以使用“如果”、“重复执行”、“退出重复”等操作来实现条件判断和循环控制，C语言中可以使用“if”、“else”、“for”、“break”等语句来实现条件判断和循环控制。 函数：iOS快捷指令中可以使用“运行快捷指令”操作来调用其他快捷指令作为函数，C语言中可以使用函数名和参数列表来定义和调用函数。 IOS快捷指令中的“重复执行每个”我总感觉像是python中的for循环，但是特别别扭 吐槽IOS的快捷指令其实更像python的语法，但是快捷指令的数据类型是真的让人头大，数据类型的辅助操作函数不丰富，像len函数这些就没有，最重要的是变量的命名太麻烦了(也可能是我不熟悉快捷指令)。 快捷指令的外部api功能非常有限，就比如只有打开app的api，没有关闭app的api(有返回桌面的api)；提供调用快捷指令api的app似乎都是苹果官方的。","categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"}],"tags":[{"name":"C","slug":"c","permalink":"https://ior.ink/tags/c/"},{"name":"随笔","slug":"jottings","permalink":"https://ior.ink/tags/jottings/"}]},{"title":"关于flutter包mqtt_client中文显示乱码的思考与解决","slug":"mqtt_client 中文显示乱码解决方案","date":"2023-12-06T12:09:00.000Z","updated":"2024-11-10T08:23:45.894Z","comments":false,"path":"posts/71907452.html","link":"","permalink":"https://ior.ink/posts/71907452.html","excerpt":"在使用flutter构建MQTT客户端时，使用的mqtt_client接收中文消息时会显示乱码。下面是对乱码的分析与解决。","text":"在使用flutter构建MQTT客户端时，使用的mqtt_client接收中文消息时会显示乱码。下面是对乱码的分析与解决。 分析经过网络搜索后发现MQTT消息乱码与消息发送和接收的编码、解码不匹配有关，所以查看消息的发送与接收函数，函数如下。 MqttPublishPayload.bytesToStringAsString(recMess.payload.message)// 来自https://www.emqx.com/zh/blog/how-to-use-mqtt-in-dart的示例 // 发布消息 client.published!.listen((MqttPublishMessage message) &#123; print(&#39;Published topic: topic is $&#123;message.variableHeader!.topicName&#125;, with Qos $&#123;message.header!.qos&#125;&#39;); &#125;); const pubTopic = &#39;test/topic&#39;; final builder = MqttClientPayloadBuilder(); builder.addString(&#39;Hello from mqtt_client&#39;); // 对消息进行编码 print(&#39;Subscribing to the $pubTopic topic&#39;); client.subscribe(pubTopic, MqttQos.exactlyOnce); print(&#39;Publishing our topic&#39;); client.publishMessage(pubTopic, MqttQos.exactlyOnce, builder.payload! // 接收消息 client.onSubscribed = onSubscribed; const topic = &#39;topic/test&#39;; print(&#39;Subscribing to the $topic topic&#39;); client.subscribe(topic, MqttQos.atMostOnce); client.updates!.listen((List&lt;MqttReceivedMessage&lt;MqttMessage?&gt;&gt;? c) &#123; final recMess = c![0].payload as MqttPublishMessage; final pt = MqttPublishPayload.bytesToStringAsString(recMess.payload.message); // 对消息进行解码 print(&#39;Received message: topic is $&#123;c[0].topic&#125;, payload is $pt&#39;); &#125;); /// The subscribed callback void onSubscribed(String topic) &#123; print(&#39;Subscription confirmed for topic $topic&#39;); &#125; 在发布消息时使用到了builder.addString(&#39;Hello from mqtt_client&#39;);， 接收消息时使用MqttPublishPayload.bytesToStringAsString(recMess.payload.message)对消息进行解码 进一步查看 addString() 函数与 byteToStringAsString() 函数 // 编码函数位于mqtt_client_payload_builder.dart内 /// Add a standard Dart string MqttClientPayloadBuilder addString(String val) &#123; addUTF16String(val); // 采用UTF16进行编码 return this; &#125; /// Add a UTF16 string, note Dart natively encodes strings as UTF16 MqttClientPayloadBuilder addUTF16String(String val) &#123; for (final codeUnit in val.codeUnits) &#123; if (codeUnit &lt;= 255 &amp;&amp; codeUnit &gt;= 0) &#123; _payload!.add(codeUnit); &#125; else &#123; addHalf(codeUnit); &#125; &#125; return this; &#125; // 解码函数位于mqtt_client_mqtt_publish_payload.dart 内 /// Converts an array of bytes to a character string. static String bytesToStringAsString(typed.Uint8Buffer message) &#123; // 接收时采用Uint8 final sb = StringBuffer(); message.forEach(sb.writeCharCode); return sb.toString(); &#125; 通过对比可知，消息显示乱码就是由于编码和解码的格式不对。 然后我就一直好奇，数据在传输过程中是什么样的格式，所以添加了显示原始消息的代码。 MqttPublishPayload.bytesToStringAsString// 接收订阅的消息 client.updates!.listen((List&lt;MqttReceivedMessage&lt;MqttMessage?&gt;&gt;? c) &#123; // 监听client的更新流 final recMess = c![0].payload as MqttPublishMessage; // 获取接收到的消息 // 将消息的负载转换为字符串 print(&quot;接收到的原始数据: $&#123;recMess.payload.message&#125;&quot;); // 查看原始数据 final pt = MqttPublishPayload.bytesToStringAsString(recMess.payload.message); try&#123; final r_base = base64Decode(pt); final row_info = utf8.decode(r_base); print(&quot;收到消息: 解密后消息内容 $row_info&quot;); // 打印收到的消息的主题和负载 &#125; on Exception &#123; print(&quot;收到消息: 主题为 $&#123;c[0].topic&#125;, 消息内容 $pt&quot;); // 打印收到的消息的主题和负载 &#125; &#125;); 获取到的数据如下 也就是说实际的数据其实是Uint8List格式，但是经过接收函数处理后，被包装成Uint8Buffer格式。 尝试我本以为这个问题比较简单，只需要把编码方式改为UTF8就行了，而我也在mqtt_client_payload_builder.dart中找到了使用UTF8格式编码的函数，所以对发送函数进行了如下的修改 // 发送函数 print(&#39;发布自己的消息&#39;); final message = MqttClientPayloadBuilder(); message.addUTF8String(sendBuffer); // 使用UTF8进行编码 client.publishMessage(pubTopic, MqttQos.exactlyOnce, message.payload!); await MqttUtilities.asyncSleep(1); 但经过测试发现，解码还是不对劲，还是解不出中文。在MQTTX软件上查看发送的消息，发现MQTTX可以正常解读我发送的中文消息了。 思考既然MQTTX可以正常显示中文了，那说明发送的问题解决了，剩下的就是接收的问题。 所以再次看了看接收的原始数据与解码函数，进入到了StringBuffer类中。 class StringBuffer implements StringSink &#123; /// Creates a string buffer containing the provided [content]. external StringBuffer([Object content = &quot;&quot;]); /// Returns the length of the content that has been accumulated so far. /// This is a constant-time operation. external int get length; /// Returns whether the buffer is empty. This is a constant-time operation. bool get isEmpty =&gt; length == 0; /// Returns whether the buffer is not empty. This is a constant-time /// operation. bool get isNotEmpty =&gt; !isEmpty; external void write(Object? object); external void writeCharCode(int charCode); external void writeAll(Iterable&lt;dynamic&gt; objects, [String separator = &quot;&quot;]); /// Writes the string representation of [object] followed by a newline. /// /// Equivalent to `buffer.write(object)` followed by `buffer.write(&quot;\\n&quot;)`. /// /// The newline is always represented as `&quot;\\n&quot;`, and does not use a platform /// specific line ending, e.g., `&quot;\\r\\n&quot;` on Windows. /// /// Notice that calling `buffer.writeln(null)` will write the `&quot;null&quot;` string /// before the newline. Omitting the argument, or explicitly passing an empty /// string, is the recommended way to emit just the newline. external void writeln([Object? obj = &quot;&quot;]); /// Clears the string buffer. external void clear(); /// Returns the contents of buffer as a single string. external String toString(); &#125; 本想继续跟踪进入**writeCharCode()**函数中，但是ide跳转不到函数实现，所以想从原始数据入手。 原始数据是Uint8List 类型，所以我打算调用dart标准库中的utf8.encode(sendBuffer) 将中文进行UTF8编码，然后将编码后的字节数据转换Uint8Buffer格式，再调用**MqttPublishPayload.bytesToStringAsString()**，看看是不是能还原出中文字符串。 import &#39;package:typed_data/typed_data.dart&#39; as typed; final test_utf8 = utf8.encode(&quot;你好，中国&quot;); print(&quot;test_utf8: $test_utf8&quot;); final test_u8buff = typed.Uint8Buffer(); test_u8buff.addAll(test_utf8); print(&quot;test_u8buff: $test_u8buff&quot;); // 试图通过MqttPublishPayload.bytesToStringAsString解码数据 print(&quot;row information: $&#123;MqttPublishPayload.bytesToStringAsString(test_u8buff)&#125;&quot;); 测试结果如下： 所以MqttPublishPayload.bytesToStringAsString函数的解码也有问题。 解决传输后的数据是Uint8List格式，所以调用utf8的解码函数就能获得我们需要的信息 // 接收订阅的消息 client.updates!.listen((List&lt;MqttReceivedMessage&lt;MqttMessage?&gt;&gt;? c) &#123; // 监听client的更新流 final recMess = c![0].payload as MqttPublishMessage; // 获取接收到的消息 // 将消息的负载转换为字符串 try &#123; final pt = Utf8Decoder().convert(recMess.payload.message); print(&quot;收到消息: 主题为 $&#123;c[0].topic&#125;, 消息内容 $pt&quot;); // 打印收到的消息的主题和负载 &#125; on FormatException &#123; // 遇到UTF16编码的数据时调用这个 final pt = MqttPublishPayload.bytesToStringAsString(recMess.payload.message); print(&quot;收到消息: 主题为 $&#123;c[0].topic&#125;, 消息内容 $pt&quot;); // 打印收到的消息的主题和负载 &#125; on Exception catch(e)&#123; print(&quot;出现问题： $e&quot;); &#125; 或者，换一种思路，既然中文直接传输有问题，那就传输base64编码后的数据。 // 对图片或其他消息进行base64编码 String to_base64(String sendBuffer) &#123; final bytes = utf8.encode(sendBuffer); String formatBuffer = base64Encode(bytes); return formatBuffer; &#125; // 解密base64编码 String r_base64(String pt) &#123; final r_base = base64Decode(pt); final row_info = utf8.decode(r_base); return row_info; &#125; 总结解决方法有两个 修复中文编码、解码问题 编码时使用UTF8编码 解码时使用utf8类中的解码函数 将包含中文的数据转换成不含中文的数据 使用base64转换","categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://ior.ink/tags/Dart/"},{"name":"MQTT","slug":"MQTT","permalink":"https://ior.ink/tags/MQTT/"}]},{"title":"关于hexo固定链接的思考","slug":"关于hexo固定链接的思考","date":"2023-12-03T16:38:00.000Z","updated":"2024-11-10T08:23:45.894Z","comments":false,"path":"posts/4519efac.html","link":"","permalink":"https://ior.ink/posts/4519efac.html","excerpt":"最近在写文章时发现一个问题，每次调用GitHub Action时都会重新生成abbrlink。","text":"最近在写文章时发现一个问题，每次调用GitHub Action时都会重新生成abbrlink。 问题我的文章源代码托管在名为blog的私人仓库中，当我修改blog仓库的内容时会自动调用GitHub action来生成html代码，并且传送到服务器和GitHub page中。为了固定文章的链接，我使用了hexo-abbrlink插件，该插件会为每一篇文章生成一个唯一的链接，不管文章的标题与时间是否发生改变。 正常的结果是只需要为每篇文章生成一次abbrlink，并会把abbrlink写入该文章的front-matter中，下次就不会重新生成abbrlink。 但是由于使用GitHub Action，修改后的文章只存在与GitHub Action的服务器上，而blog仓库中的文章并没有添加abbrlink信息。 思考我目前只想到两种自动化的解决方式，第一种是自己提前生成文章的abbrlink，而不是由hexo-abbrlink生成。第二种是将存在于GitHub Action服务器上经过修改的文章推送到blog仓库。 方案一我可以自己使用时间戳以及front-matter中的变量作为参数生成一个随机的短链接，用这种方式生成的短链接每次都不一样。 我也可以使用hexo-abbrlink的代码构建一个网页版的hexo-abbrlink，采用这种方式生成的短链接不随时间和标题的改变，也不会重复。 脑子一热后我使用了第二种方式，下面是对hexo-abbrlink的一些解读。试了这种方式后发现这个插件还使用了别的hexo插件，我还要花时间去看其他插件的源码，所以暂时就不用这种方式了。 // logic.js // 引入CRC16和CRC32模块 var crc16 = require(&#39;./crc16&#39;); var crc32 = require(&#39;./crc32&#39;); // 引入模型和前端处理模块 var model = require(&#39;./model&#39;); var front = require(&#39;hexo-front-matter&#39;); // 引入文件系统模块 var fs = require(&#39;hexo-fs&#39;); // 定义一个函数来获取文章的abbrlink function org_get_abbrlink(data) &#123; // 使用正则表达式匹配内容中的ABBRLINK标记 var r = data.content.match(/#\\+ABBRLINK:.*\\n/); if (r) &#123; // 如果匹配到了，就从匹配结果中提取abbrlink data.abbrlink = r[0].split(&#39;:&#39;)[1].trim(); &#125; else &#123; // 如果没有匹配到，就将abbrlink设置为空 data.abbrlink = &#39;&#39;; &#125; return data; &#125; // 定义一个逻辑函数来处理数据 let logic = function(data) &#123; // 获取日志对象 var log = this.log; // 获取配置信息，如果没有则设置为空对象 const config = this.config.abbrlink || &#123;&#125;; // 处理草稿的选项 var opt_drafts = this.config.abbrlink &amp;&amp; this.config.abbrlink.drafts ? this.config.abbrlink.drafts : false; // 如果不处理草稿并且数据源来自草稿，则直接返回数据 if (opt_drafts == false) &#123; if (!this.config.render_drafts &amp;&amp; data.source.startsWith(&#39;_drafts/&#39;)) return data; &#125; // 如果数据布局为&#39;post&#39;，则进行以下处理 if (data.layout == &#39;post&#39;) &#123; let abbrlink; // 如果数据源不是以&#39;.org&#39;结尾，则直接使用数据中的abbrlink if (!/.*\\.org/.test(data.source)) &#123; abbrlink = data.abbrlink; &#125; else &#123; // 否则，调用org_get_abbrlink函数获取abbrlink abbrlink = org_get_abbrlink(data) .abbrlink; &#125; // 获取根路径 let root_path = data.source.startsWith(&#39;_drafts/&#39;) ? &#39;source/_drafts&#39; : &#39;source/_posts&#39; // 重新解析前端数据 var tmpPost = front.parse(data.raw); // 自动标题处理 // 如果配置了自动标题并且临时文章没有标题，则进行处理 if (this.config.abbrlink &amp;&amp; this.config.abbrlink.auto_title &amp;&amp; !tmpPost.title) &#123; // 分割路径，获取最后一部分作为标题 const pathParts = data.source.split(&#39;/&#39;); let last = pathParts[pathParts.length - 1]; let last2 = pathParts[pathParts.length - 2]; // 处理文件扩展名 const endPort2 = last2.lastIndexOf(&#39;.&#39;); var last2tail = &#39;&#39; var last2front = &#39;&#39; if (endPort2 &gt; -1) &#123; last2tail = last2.substring(endPort2 + 1); last2front = last2.substring(0, endPort2); &#125; // 如果文件扩展名为&#39;textbundle&#39;，则使用前面的部分作为标题 if (last2tail == &#39;textbundle&#39;) &#123; tmpPost.title = last2front; &#125; else &#123; // 否则，处理最后一部分的文件扩展名 const endPort = last.indexOf(&#39;.&#39;); if (endPort &gt; -1) &#123; last = last.substring(0, endPort); &#125; // 设置标题为最后一部分的文件名 tmpPost.title = last; &#125; // 如果数据中没有标题，则记录日志 if (data.title.length == 0) log.i(&#39;No title [%s] in post [ %s ]&#39;, data.title, data.full_source); // 记录生成的标题日志 log.i(&#39;Generated: title [%s] for post [ %s ]&#39;, tmpPost.title, data.full_source); &#125; // 自动日期处理 // 如果配置了自动日期并且临时文章没有日期，则进行处理 if (this.config.abbrlink &amp;&amp; this.config.abbrlink.auto_date &amp;&amp; !tmpPost.date) &#123; // 设置日期为数据中的日期格式 tmpPost.date = data.date.format(&#39;YYYY-MM-DD HH:mm:ss&#39;); // 记录生成的日期日志 log.i(&#39;Generated: date [%s] for post [ %s ]&#39;, tmpPost.date, data.full_source); &#125; // 自动分类处理（来自hexo-auto-category插件） var opt_AutoCategoryEnable = config.auto_category &amp;&amp; config.auto_category.enable; var overwrite = config.auto_category &amp;&amp; config.auto_category.over_write; // 如果启用了自动分类并且配置了覆盖，则进行处理 if (opt_AutoCategoryEnable &amp;&amp; overwrite) &#123; // 分割路径，获取分类 var categories = data.source.split(&#39;/&#39;); // 处理分类中的文件扩展名 if (categories.length - 2 &gt;= 0) &#123; let last2 = categories[categories.length - 2]; const endPort2 = last2.lastIndexOf(&#39;.&#39;); var last2tail = &#39;&#39; var last2front = &#39;&#39; if (endPort2 &gt; -1) &#123; last2tail = last2.substring(endPort2 + 1); last2front = last2.substring(0, endPort2); &#125; // 如果文件扩展名为&#39;textbundle&#39;，则从分类中移除最后一部分 if (last2tail == &#39;textbundle&#39;) &#123; categories.pop(); &#125; &#125; // 如果分类深度为0或者路径长度为2，则设置默认分类 if (categories.length - 2 == 0 || depth == 0) &#123; tmpPost.categories = this.config.default_category; &#125; else &#123; // 否则，根据深度设置分类 var newCategories = categories.slice(1, 1 + Math.min(depth, categories.length - 2)); //prevents duplicate file changes if ( !Array.isArray(tmpPost.categories) || tmpPost.categories.join(&#39;_&#39;) != newCategories.join(&#39;_&#39;) ) &#123; tmpPost.categories = newCategories; log.i(&#39;Generated: categories [%s] for post [ %s ]&#39;, tmpPost.categories, data.full_source); &#125; &#125; &#125; // 如果没有abbrlink，或者abbrlink为&#39;0&#39;，或者配置中强制要求生成新的abbrlink if (!abbrlink || abbrlink == &#39;0&#39; || config.force) &#123; // 根据配置选择算法，默认为&#39;crc16&#39; var opt_alg = this.config.abbrlink &amp;&amp; this.config.abbrlink.alg ? this.config.abbrlink.alg : &#39;crc16&#39;; // 根据配置选择表示方法，默认为&#39;dec&#39; var opt_rep = this.config.abbrlink &amp;&amp; this.config.abbrlink.rep ? this.config.abbrlink.rep : &#39;dec&#39;; // 根据选定的算法计算abbrlink let res = opt_alg == &#39;crc32&#39; ? crc32.str(tmpPost.title + tmpPost.date) &gt;&gt;&gt; 0 : crc16(tmpPost.title + tmpPost.date) &gt;&gt;&gt; 0; // 检查生成的abbrlink是否已存在，如果存在则获取一个不同的值 abbrlink = model.check(res); // 将abbrlink设置为十六进制或十进制 abbrlink = opt_rep == &#39;hex&#39; ? abbrlink.toString(16) : abbrlink; // 更新data和tmpPost对象的abbrlink属性 data.abbrlink = abbrlink; tmpPost.abbrlink = abbrlink; // 记录日志 log.i(&#39;Generated: link [%s] for post [ %s ]&#39;, tmpPost.abbrlink, data.full_source); &#125; // 将abbrlink转换为整数 let abbrlink_int = opt_rep == &#39;hex&#39; ? parseInt(&#39;0x&#39; + abbrlink) : abbrlink // 将新生成的abbrlink添加到模型中 model.add(abbrlink_int); // 定义一个变量来存储文章字符串 let postStr; // 如果文章源文件不是.org格式 if (!/.*\\.org/.test(data.source)) &#123; // 将tmpPost对象转换为字符串，并添加YAML前缀 postStr = front.stringify(tmpPost); postStr = &#39;---\\n&#39; + postStr; // 将字符串写入源文件 fs.writeFileSync(data.full_source, postStr, &#39;utf-8&#39;); &#125; else &#123; // 如果是.org格式，将abbrlink添加到文件的第二行 postStr = data.raw.split(&#39;\\n&#39;); postStr.splice(2, 0, &#39;#+ABBRLINK: &#39; + abbrlink); // 将更新后的内容写回源文件 fs.writeFileSync(data.full_source, postStr.join(&#39;\\n&#39;), &#39;utf-8&#39;); &#125; &#125; return data &#125;; 需要注意的地方是 检查abbrlink是否唯一使用model.check函数检查abbrlink是否唯一，如果不唯一则获取一个不同的值。然后将这个值添加到模型中，以便跟踪所有生成的abbrlink。 更新文章源文件根据文章的源文件格式，将新的abbrlink添加到文章的Front-matter中（对于非.org文件）或文件的第二行（对于.org文件），然后将更新后的内容写回源文件。 // model.js // CRC表，包含了预计算的CRC校验值 let CrcTable = new Array( // ... 数组中的值 ... ); // 处理函数，用于计算单个字节的CRC值 let deal = function(crc, b) &#123; // 将当前CRC值右移8位，然后与CRC表中的值进行异或运算 return (crc &gt;&gt; 8) ^ CrcTable[(crc &amp; 0xFF) ^ b]; &#125;; // 预处理函数，用于处理整个数据块并计算其CRC值 let preDeal = function(data, len) &#123; var crc = 0; // 初始化CRC值为0 for (var i = 0; i &lt; len; i++) &#123; // 对数据块中的每个字节调用处理函数 crc = deal(crc, data[i]); &#125; return crc; // 返回计算得到的CRC值 &#125;; // 导出模块，允许其他文件使用这个CRC计算功能 module.exports = function(str) &#123; var buffer = new Buffer(str); // 将传入的字符串转换为Buffer对象 return preDeal(buffer, buffer.length); // 调用预处理函数计算CRC值 &#125; hexo-abbrlink的主要逻辑都在这里，其他的不太重要，就没仔细看了 方案二选择该方案其实有一个逻辑上的bug，就目前的配置而言： GitHub Action会在blog仓库发生变动的第一时间进行启动，而GitHub Action将修改后的文章推送到blog仓库又会导致GitHub Action的启动，所以会导致死循环。 要解决这个问题就要找出一种方式使得GitHub的触发可控，接受来自GitHub Action服务器的推送时不会触发Action。这个方法我目前还没找到。","categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"}],"tags":[{"name":"JS","slug":"js","permalink":"https://ior.ink/tags/js/"}]},{"title":"Hexo博客Front-matter快速生成器","slug":"front-matter-generate","date":"2023-12-02T11:25:00.000Z","updated":"2024-11-10T08:23:45.894Z","comments":false,"path":"posts/f69ceea3.html","link":"","permalink":"https://ior.ink/posts/f69ceea3.html","excerpt":"在写博客的时候，每次都需要手写Front-matter，比较麻烦，于是写了一个快速生成器。","text":"在写博客的时候，每次都需要手写Front-matter，比较麻烦，于是写了一个快速生成器。 效果请在ior.ink&#x2F;gen页面体验 代码 &lt;html lang=&quot;zh-CN,en,zh-HK,default&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; label &#123; font-weight: bold; margin-bottom: 5px; &#125; /* 添加圆角 */ .container &#123; width: 800px; margin: 0 auto; padding: 20px; &#125; .row &#123; display: flex; align-items: center; margin-bottom: 10px; &#125; .col-1 &#123; flex: 0 0 100px; margin: auto; &#125; .col-2 &#123; flex: 1 1 auto; &#125; .checkbox &#123; margin-left: 10px; margin-right: 0px; &#125; .add &#123; margin-left: 10px; margin-right: 0px; padding: 5px; background-color: #007bff; color: #fff; border: none; border-radius: 3px; cursor: pointer; &#125; option &#123; background-color: #f9f9f9; /* 设置选项的背景颜色 */ color: black; /* 设置选项的文字颜色 */ text-align: center; /* 设置选项的文字对齐方式 */ &#125; button, input, textarea &#123; padding: 5px; margin: 5px; border: 1px solid rgba(6, 6, 6, 0.731); border-radius: 3px; box-sizing: border-box; outline: none; font-size: 16px; font-family: &#39;Microsoft YaHei&#39;, &#39;微软雅黑&#39;; color: #333; background-color: #fff; resize: none; /* 禁止拖动 */ &#125; select &#123; width: auto; padding: 5px; margin: 5px; border: 1px solid rgba(18, 11, 11, 0.731); border-radius: 3px; box-sizing: border-box; outline: none; font-size: 16px; font-family: &#39;Microsoft YaHei&#39;, &#39;微软雅黑&#39;; color: #333; background-color: #fff; cursor: pointer; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Hexo博客Front-matter快速生成器&lt;/h1&gt; &lt;p&gt;你可以在这里编辑你的md文件的内容，然后点击“生成md代码”按钮，就可以得到一段md格式的代码，你可以复制并粘贴到你的md文件中。&lt;/p&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;label for=&quot;title&quot;&gt;标题&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;title&quot; name=&quot;title&quot; placeholder=&quot;请输入标题&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;label for=&quot;tags&quot;&gt;标签&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;div id=&quot;tags&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;tag-1&quot; name=&quot;tag-1&quot; class=&quot;checkbox&quot; value=&quot;C&quot; /&gt; &lt;label for=&quot;tag-1&quot;&gt;C&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;tag-2&quot; name=&quot;tag-2&quot; class=&quot;checkbox&quot; value=&quot;Python&quot; /&gt; &lt;label for=&quot;tag-2&quot;&gt;Python&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;tag-3&quot; name=&quot;tag-3&quot; class=&quot;checkbox&quot; value=&quot;C++&quot; /&gt; &lt;label for=&quot;tag-3&quot;&gt;C++&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;tag-4&quot; name=&quot;tag-4&quot; class=&quot;checkbox&quot; value=&quot;Go&quot; /&gt; &lt;label for=&quot;tag-4&quot;&gt;Go&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;tag-5&quot; name=&quot;tag-5&quot; class=&quot;checkbox&quot; value=&quot;JS&quot; /&gt; &lt;label for=&quot;tag-5&quot;&gt;JS&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;tag-6&quot; name=&quot;tag-6&quot; class=&quot;checkbox&quot; value=&quot;YAML&quot; /&gt; &lt;label for=&quot;tag-6&quot;&gt;YAML&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;tag-7&quot; name=&quot;tag-7&quot; class=&quot;checkbox&quot; value=&quot;随笔&quot; /&gt; &lt;label for=&quot;tag-7&quot;&gt;随笔&lt;/label&gt; &lt;button id=&quot;add-tag&quot; class=&quot;add&quot;&gt;添加标签&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;label for=&quot;headimg&quot;&gt;头图&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;headimg&quot; name=&quot;headimg&quot; placeholder=&quot;请输入图片地址，或者留空&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;label for=&quot;group&quot;&gt;分组&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;select id=&quot;group&quot; name=&quot;group&quot;&gt; &lt;option value=&quot;group-1&quot;&gt;group-1&lt;/option&gt; &lt;option value=&quot;group-2&quot;&gt;group-2&lt;/option&gt; &lt;option value=&quot;group-3&quot;&gt;group-3&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;label for=&quot;categories&quot;&gt;分类&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;div id=&quot;categories&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;category-1&quot; name=&quot;category-1&quot; class=&quot;checkbox&quot; value=&quot;代码学习&quot; /&gt; &lt;label for=&quot;category-1&quot;&gt;代码学习&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;category-2&quot; name=&quot;category-2&quot; class=&quot;checkbox&quot; value=&quot;硬件学习&quot; /&gt; &lt;label for=&quot;category-2&quot;&gt;硬件学习&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;category-3&quot; name=&quot;category-3&quot; class=&quot;checkbox&quot; value=&quot;软件折腾&quot; /&gt; &lt;label for=&quot;category-3&quot;&gt;软件折腾&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;category-4&quot; name=&quot;category-4&quot; class=&quot;checkbox&quot; value=&quot;硬件折腾&quot; /&gt; &lt;label for=&quot;category-4&quot;&gt;硬件折腾&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;category-5&quot; name=&quot;category-5&quot; class=&quot;checkbox&quot; value=&quot;杂项&quot; /&gt; &lt;label for=&quot;category-5&quot;&gt;杂项&lt;/label&gt; &lt;button id=&quot;add-category&quot; class=&quot;add&quot;&gt;添加分类&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;label for=&quot;abbrlink&quot;&gt;缩略链接&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;abbrlink&quot; name=&quot;abbrlink&quot; placeholder=&quot;请输入缩略链接，或者留空&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;label for=&quot;date&quot;&gt;日期&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;input type=&quot;datetime-local&quot; id=&quot;date&quot; name=&quot;date&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;label for=&quot;comments&quot;&gt;评论&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;select id=&quot;comments&quot; name=&quot;comments&quot;&gt; &lt;option value=&quot;false&quot;&gt;关闭&lt;/option&gt; &lt;option value=&quot;true&quot;&gt;开启&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-1&quot;&gt; &lt;button id=&quot;generate&quot;&gt;生成md代码&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;col-2&quot;&gt; &lt;textarea id=&quot;output&quot; name=&quot;output&quot; rows=&quot;10&quot; cols=&quot;80&quot; readonly&gt;&lt;/textarea&gt; &lt;button id=&quot;copy&quot;&gt;一键复制&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取元素 var title = document.getElementById(&quot;title&quot;); var tags = document.getElementById(&quot;tags&quot;); var headimg = document.getElementById(&quot;headimg&quot;); var group = document.getElementById(&quot;group&quot;); var categories = document.getElementById(&quot;categories&quot;); var abbrlink = document.getElementById(&quot;abbrlink&quot;); var date = document.getElementById(&quot;date&quot;); var comments = document.getElementById(&quot;comments&quot;); var generate = document.getElementById(&quot;generate&quot;); var output = document.getElementById(&quot;output&quot;); var add_Tag = document.getElementById(&quot;add-tag&quot;); var add_Category = document.getElementById(&quot;add-category&quot;); // 定义生成md代码的函数 function generateMdCode() &#123; // 获取输入的值 var titleValue = title.value; var tagsValue = &quot;&quot;; var headimgValue = headimg.value; var groupValue = group.value; var categoriesValue = &quot;&quot;; var abbrlinkValue = abbrlink.value; var dateValue = date.value; var commentsValue = comments.value; // 检查输入的值是否合法 if (titleValue == &quot;&quot;) &#123; alert(&quot;请输入标题&quot;); return; &#125; var tagInputs = tags.getElementsByTagName(&quot;input&quot;); var tagCount = 0; for (var i = 0; i &lt; tagInputs.length; i++) &#123; if (tagInputs[i].checked) &#123; tagCount++; tagsValue += tagInputs[i].value + &quot;,&quot;; &#125; &#125; if (tagCount == 0) &#123; alert(&quot;请选择至少一个标签&quot;); return; &#125; tagsValue = tagsValue.slice(0, -1); // 去掉最后一个逗号 var categoryInputs = categories.getElementsByTagName(&quot;input&quot;); var categoryCount = 0; for (var i = 0; i &lt; categoryInputs.length; i++) &#123; if (categoryInputs[i].checked) &#123; categoryCount++; categoriesValue += categoryInputs[i].value + &quot;,&quot;; &#125; &#125; if (categoryCount == 0) &#123; alert(&quot;请选择至少一个分类&quot;); return; &#125; categoriesValue = categoriesValue.slice(0, -1); // 去掉最后一个逗号 if (dateValue == &quot;&quot;) &#123; alert(&quot;请输入日期&quot;); return; &#125; // 生成md代码 var mdCode = &quot;---\\n&quot;; mdCode += &quot;title: &quot; + titleValue + &quot;\\n&quot;; mdCode += &quot;tags: \\n&quot;; var tagsArray = tagsValue.split(&quot;,&quot;); for (var i = 0; i &lt; tagsArray.length; i++) &#123; mdCode += &quot; - &quot; + tagsArray[i].trim() + &quot;\\n&quot;; &#125; if (headimgValue != &quot;&quot;) &#123; // alert(&quot;请输入头图的网址&quot;); mdCode += &quot;headimg: &quot; + headimgValue + &quot;\\n&quot;; // return; &#125; mdCode += &quot;group: &quot; + groupValue + &quot;\\n&quot;; mdCode += &quot;categories: \\n&quot;; var categoriesArray = categoriesValue.split(&quot;,&quot;); for (var i = 0; i &lt; categoriesArray.length; i++) &#123; mdCode += &quot; - [&quot; + categoriesArray[i].trim() + &quot;]\\n&quot;; &#125; mdCode += &quot;abbrlink: &quot; + abbrlinkValue + &quot;\\n&quot;; mdCode += &quot;date: &quot; + dateValue.slice(0,10).replace(/-/g, &quot;/&quot;) + &quot; &quot; + dateValue.slice(11,) + &quot;:00\\n&quot;; mdCode += &quot;comments: &quot; + commentsValue + &quot;\\n&quot;; mdCode += &quot;---\\n&quot;; mdCode += &quot;\\n&lt;!-- more--&gt;\\n&quot;; // 显示md代码 output.value = mdCode; // 修改按钮的文字 copy.innerText = &quot;一键复制&quot;; &#125; // 定义添加标签的函数 function addTag() &#123; // 获取输入的值 var newTag = prompt(&quot;请输入新的标签&quot;); if (newTag == null || newTag == &quot;&quot;) &#123; return; &#125; // 检查是否已经存在相同的标签 var tagInputs = tags.getElementsByTagName(&quot;input&quot;); for (var i = 0; i &lt; tagInputs.length; i++) &#123; if (tagInputs[i].value == newTag) &#123; alert(&quot;该标签已经存在&quot;); return; &#125; &#125; // 生成新的标签元素 var newTagInput = document.createElement(&quot;input&quot;); newTagInput.type = &quot;checkbox&quot;; newTagInput.id = &quot;tag-&quot; + (tagInputs.length + 1); newTagInput.name = &quot;tag-&quot; + (tagInputs.length + 1); newTagInput.value = newTag; newTagInput.className = &quot;checkbox&quot;; var newTagLabel = document.createElement(&quot;label&quot;); newTagLabel.htmlFor = &quot;tag-&quot; + (tagInputs.length + 1); newTagLabel.innerText = newTag; // 插入新的标签元素 tags.insertBefore(newTagInput, add_Tag); tags.insertBefore(newTagLabel, add_Tag); &#125; // 定义添加分类的函数 function addCategory() &#123; // 获取输入的值 var newCategory = prompt(&quot;请输入新的分类&quot;); if (newCategory == null || newCategory == &quot;&quot;) &#123; return; &#125; // 检查是否已经存在相同的分类 var categoryInputs = categories.getElementsByTagName(&quot;input&quot;); for (var i = 0; i &lt; categoryInputs.length; i++) &#123; if (categoryInputs[i].value == newCategory) &#123; alert(&quot;该分类已经存在&quot;); return; &#125; &#125; // 生成新的分类元素 var newCategoryInput = document.createElement(&quot;input&quot;); newCategoryInput.type = &quot;checkbox&quot;; newCategoryInput.id = &quot;category-&quot; + (categoryInputs.length + 1); newCategoryInput.name = &quot;category-&quot; + (categoryInputs.length + 1); newCategoryInput.value = newCategory; newCategoryInput.className = &quot;checkbox&quot;; var newCategoryLabel = document.createElement(&quot;label&quot;); newCategoryLabel.htmlFor = &quot;category-&quot; + (categoryInputs.length + 1); newCategoryLabel.innerText = newCategory; // 插入新的分类元素 categories.insertBefore(newCategoryInput, add_Category); categories.insertBefore(newCategoryLabel, add_Category); &#125; // 定义复制输出框的内容的函数 function copyOutput() &#123; // 获取输出框的内容 var outputValue = output.value; // 检查输出框是否为空 if (outputValue == &quot;&quot;) &#123; alert(&quot;请先生成md代码&quot;); return; &#125; // 复制输出框的内容 output.select(); document.execCommand(&quot;copy&quot;); document.getSelection().removeAllRanges(); // 修改按钮的文字 copy.innerText = &quot;已复制&quot;; &#125; // 绑定点击事件 generate.addEventListener(&quot;click&quot;, generateMdCode); add_Tag.addEventListener(&quot;click&quot;, addTag); add_Category.addEventListener(&quot;click&quot;, addCategory); copy.addEventListener(&quot;click&quot;, copyOutput); &lt;/script&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"杂项","slug":"Miscellaneous","permalink":"https://ior.ink/categories/Miscellaneous/"}],"tags":[{"name":"JS","slug":"js","permalink":"https://ior.ink/tags/js/"}]},{"title":"KNN算法简单实现","slug":"KNN算法简单实现","date":"2023-05-10T23:53:58.000Z","updated":"2024-11-10T08:23:45.894Z","comments":false,"path":"posts/3dbe41d6.html","link":"","permalink":"https://ior.ink/posts/3dbe41d6.html","excerpt":"最近在机器学习课堂上学习了KNN算法，在课程作业中终于出现了KNN算法具体实现的题目，在此记录一下我的解题思路.","text":"最近在机器学习课堂上学习了KNN算法，在课程作业中终于出现了KNN算法具体实现的题目，在此记录一下我的解题思路. 题目说明补充 python 代码，完成 kNNClassifier 类中的 fit 函数与 predict 函数。实现 kNN 算法的训练与预测功能。 基础代码如下： #encoding=utf8 import numpy as np class kNNClassifier(object): def __init__(self, k): &#39;&#39;&#39; 初始化函数 :param k:kNN算法中的k &#39;&#39;&#39; self.k = k # 用来存放训练数据，类型为ndarray self.train_feature = None # 用来存放训练标签，类型为ndarray self.train_label = None def fit(self, feature, label): &#39;&#39;&#39; kNN算法的训练过程 :param feature: 训练集数据，类型为ndarray :param label: 训练集标签，类型为ndarray :题目是return: 无返回 &#39;&#39;&#39; #********* Begin *********# #********* End *********# def predict(self, feature): &#39;&#39;&#39; kNN算法的预测过程 :param feature: 测试集数据，类型为ndarray :return: 预测结果，类型为ndarray或list &#39;&#39;&#39; #********* Begin *********# #********* End *********# 解题思路1.题目是要求实现kNNClassifier中的fit方法，fit()方法会接受两个参数：训练数据X和目标变量y。 其中，X是一个二维数组，包含了训练样本点的特征向量，每行代表一个样本点，每列代表一个特征。如 [ [x1,y1,z1,w1] [x2,y2,z2,w2] [x3,y3,z3,w3] ... ] y是一个一维数组，包含了训练样本点的目标变量，即每个样本点的分类标签。如 [label1, label2, label3, ...] fit()方法利用给定的训练数据集生成一个KNN模型，其作用有点像在空白纸上将数据中的点根据(x,y)的值绘制出来。接下来的预测则是把不确定的点也在该纸上画出来，并且找到离不确定点的距离最近的几个点。 所以fit()的功能应该是储存数据，以便被预测函数调用。 2.kNNClassifier中的predict()方法有额外一个参数，该参数是需要预测标签的点或者是点的集合。 在predict()中，首先要计算预测点离模型中每个点的距离，然后选出距离该点最近的K个点，统计K个点的标签，出现次数最多的标签则为预测点的标签。 3.在确定了两个函数的大概方法后，为了解题方便最好再确认一下所给数据的格式，每个数据的格式如下 print(feature.shape) ===&gt; (38, 4) print(self.train_feature.shape) ===&gt; (112, 4) print(self.train_label.shape) ===&gt; (112,) 根据上面的信息可以得出，训练数据集中共有112个数据，每个数据都有4个特征和一个标签；预测数据集中有38个数据，每个数据也都是4个特征，需要根据对应4个特征预测出其标签。 每次都从预测数据集中取出一个数据放入模型中，最后返回的标签也需要以集合的形式返回，所以在predict函数中需要使用for循环。 具体实现 fit()方法的实现 def fit(self, feature, label): &#39;&#39;&#39; kNN算法的训练过程 :param feature: 训练集数据，类型为ndarray :param label: 训练集标签，类型为ndarray :return: 无返回 &#39;&#39;&#39; #********* Begin *********# self.train_feature = feature self.train_label = label #********* End *********# predict()方法的实现 def predict(self, feature): &#39;&#39;&#39; kNN算法的预测过程 :param feature: 测试集数据，类型为ndarray :return: 预测结果，类型为ndarray或list &#39;&#39;&#39; #********* Begin *********# # 确定数据的个数 num_test = feature.shape[0] # 定义返回标签集合 y_pred = np.zeros(num_test, dtype = self.train_label.dtype) # 每次取出一个预测数据 for i in range(num_test): # 计算预测值特征与模型中每个点特征值的差 error = np.abs(self.train_feature - feature[i,:]) # 将4个特征值的差合并为一个差，并将其定义为距离 distances = np.sum(error, axis = 1) # 返回distances中从大到小的前K个数的索引 indices = np.argsort(distances)[:self.k] # 将feature中的索引转换成对应的标签 # self.train_label[indices]返回最大距离数据对应的标签 feature_to_label = self.train_label[indices] # 将出现次数最多的标签置入对应的标签组中 # np.argmax(np.bincount(array)) 返回数组中出现次数最多的数 y_pred[i] = np.argmax(np.bincount(feature_to_label)) return y_pred","categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://ior.ink/tags/python/"}]},{"title":"hexo博客文章、分类、标签网址全英文化","slug":"hexo博客文章、分类、标签网址全英文化","date":"2023-04-21T14:00:36.000Z","updated":"2024-11-10T08:23:45.894Z","comments":false,"path":"posts/5120accd.html","link":"","permalink":"https://ior.ink/posts/5120accd.html","excerpt":"本文将帮助你使用abbrlink、tag_map和category_map实现URL路径全英文。","text":"本文将帮助你使用abbrlink、tag_map和category_map实现URL路径全英文。 文章链接去中文1.首先在博客根目录运行Git Bash，输入以下指令安装hexo-abbrlink： npm install hexo-abbrlink --save 2.打开站点配置文件 _config.yml，修改permalink为： permalink: posts/:abbrlink.html 3,.在站点配置文件 _config.yml 中添加以下代码： #abbrlink配置 abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 注：其中alg和rep为算法和进制 算法 进制 crc16 hex crc32 dec 4.修改文件后，重新生成文章即可 hexo clean hexo g 分类去中文化使用category_map实现分组映射 打开站点配置文件 _config.yml，修改 category_map: # Category &amp; Tag default_category: uncatalog ## 为了让中文分组名在网址中显示为英文，我们可以创建分组名映射（category_map）： category_map: &#39;Adobe脚本语言学习&#39; : adobe-extendscript &#39;Android基础&#39; : android-base &#39;Android案例实现&#39; : android-training &#39;Hexo&#39; : hexo 标签去中文化使用tag_map实现分组映射 打开站点配置文件**_config.yml，修改tag_map**: # Category &amp; Tag default_category: uncatalog ## 为了让中文分组名在网址中显示为英文，我们可以创建分组名映射（category_map）： category_map: &#39;Adobe脚本语言学习&#39; : adobe-extendscript &#39;Android基础&#39; : android-base &#39;Android案例实现&#39; : android-training &#39;Hexo&#39; : hexo tag_map: &#39;标签一&#39; : tag1 &#39;标签二&#39; : tag2","categories":[{"name":"杂项","slug":"Miscellaneous","permalink":"https://ior.ink/categories/Miscellaneous/"}],"tags":[{"name":"YAML","slug":"yaml","permalink":"https://ior.ink/tags/yaml/"}]},{"title":"volantis自定义主题","slug":"volantis自定义主题","date":"2022-11-25T00:06:55.000Z","updated":"2024-11-10T08:23:45.894Z","comments":false,"path":"posts/79aa5ff0.html","link":"","permalink":"https://ior.ink/posts/79aa5ff0.html","excerpt":"","text":"在实际使用过程中，虽然可以通过_config.volantis.yaml文件来设置主题，但是这些设置都是在volantis内置模板的基础上实现的。如果对某个模板不太满意，就需要自己动手更改模板。好在volantis提供的强大自定义功能。 # 修改布局 布局通过ejs文件来实现，ejs的语法非常简单，可以在其ejs官网找到。 修改布局有两种方法，不管哪一种方法，都需要创建 blog&#x2F;source&#x2F;_volantis&#x2F; 文件夹，并在该文件夹中添加自定义的ejs文件或者styl文件。 # 注入修改法 注入修改法是volantis官方推荐的修改方法，通过向留在特定文件的注入点添加内容实现修改。你仅能在特定文件的开头与结尾添加自己的代码，无法修改原来存在的代码。 需要注意的是，你需要在_volantis文件夹中创建特定名称的ejs文件。例如你在 _volantis&#x2F;bodyEnd.ejs 文件中写入的代码会被注入到 theme&#x2F;layout&#x2F;layout.ejs 文件的 标签末尾。具体的文件名称与注入点如下所示： headBegin.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;head.ejs 文件 标签开头注入自定义内容. headEnd.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;head.ejs 文件 标签末尾注入自定义内容. header.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;header.ejs 文件 导航栏 .nav-main 末尾注入自定义内容. side.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;side.ejs 文件 侧边栏 #l_side 末尾注入自定义内容. topMeta.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;meta.ejs 文件 topMetas 末尾注入自定义内容. bottomMeta.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;meta.ejs 文件 bottomMetas 末尾注入自定义内容. footer.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;footer.ejs 文件 标签末尾注入自定义内容. postEnd.ejs: 向 theme&#x2F;layout&#x2F;_partial&#x2F;article.ejs 文件 标签末尾注入自定义内容. bodyBegin.ejs: 向 theme&#x2F;layout&#x2F;layout.ejs 文件 标签开头注入自定义内容. bodyEnd.ejs: 向 theme&#x2F;layout&#x2F;layout.ejs 文件 标签末尾注入自定义内容. # 重写修改法 如果对已有的布局不满意，你也可以选择重写，建议重写的文件放置在 _volantis 文件夹下，并与源文件名称一致。为了用重写的文件替代源文件，你需要 hexo-extend-theme 插件，该插件的使用方法可以在插件的ReadMe文件中看。 # 修改样式表 样式表的修改和布局一样，都可以在文档中找到","categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"}],"tags":[{"name":"JS","slug":"js","permalink":"https://ior.ink/tags/js/"}]}],"categories":[{"name":"代码学习","slug":"CodeLearning","permalink":"https://ior.ink/categories/CodeLearning/"},{"name":"杂项","slug":"Miscellaneous","permalink":"https://ior.ink/categories/Miscellaneous/"}],"tags":[{"name":"C","slug":"c","permalink":"https://ior.ink/tags/c/"},{"name":"随笔","slug":"jottings","permalink":"https://ior.ink/tags/jottings/"},{"name":"Dart","slug":"Dart","permalink":"https://ior.ink/tags/Dart/"},{"name":"MQTT","slug":"MQTT","permalink":"https://ior.ink/tags/MQTT/"},{"name":"JS","slug":"js","permalink":"https://ior.ink/tags/js/"},{"name":"Python","slug":"python","permalink":"https://ior.ink/tags/python/"},{"name":"YAML","slug":"yaml","permalink":"https://ior.ink/tags/yaml/"}]}